

Given an array arr of n numbers
To evaluate value of f(L, R) where f(L, R) = arr[L] o arr[L + 1]......arr[R - 1] o arr[R]
o can be +, * and ^ (xor)



Why only these ? 
because they are commutative and have inverse operator
+, - and ^ are all commutative and -, + and ^ are their inverse operator respectively

Let's call the inverse operator as o'

Let's say we know f(1, 5) and f(1, 3)

Can we find f(4, 5) ?
Let's see

a - Consider o to be +
f(1, 5) = arr[1] + arr[2] + arr[3] + arr[4] + arr[5]
f(1, 3) = arr[1] + arr[2] + arr[3]

We need to find f(4, 5) = arr[4] + arr[5]
f(1, 5) - f(1, 3) = (arr[1] + arr[2] + arr[3] + arr[4] + arr[5]) - (arr[1] + arr[2] + arr[3])
                  = arr[4] + arr[5]     

b - consider o to be *  
f(1, 5) = arr[1] * arr[2] * arr[3] * arr[4] * arr[5]     
f(1, 3) = arr[1] * arr[2] * arr[3]
we need to find f(4, 5) = arr[4] * arr[5]
f(1, 5) / f(1, 3) = (arr[1] * arr[2] * arr[3] * arr[4] * arr[5]) / (arr[1] * arr[2] * arr[3])
                  = arr[4] * arr[5]    

c - consider o to be ^
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0

a ^ a = 0
a ^ 0 = a

f(1, 5) = arr[1] ^ arr[2] ^ arr[3] ^ arr[4] ^ arr[5]     
f(1, 3) = arr[1] ^ arr[2] ^ arr[3]
we need to find f(4, 5) = arr[4] ^ arr[5]
f(1, 5) ^ f(1, 3) = (arr[1] ^ arr[2] ^ arr[3] ^ arr[4] ^ arr[5]) ^ (arr[1] ^ arr[2] ^ arr[3])
                  = arr[4] ^ arr[5]   


So we see f(b, c) can be calculated as f(a, c) o' f(a, b - 1) , a <= b <= c


Since a has to be smaller than every value of b and c, let's take a the smallest possible index
generally a is 0 or 1

let's say we have an array pref and pref[i] = f(0, i)

// calculating pref array
pref[0] = a[0]
pref[1] = pref[0] + a[1]
pref[2] = pref[1] + a[2]

for(int i = 1; i < n; i++) {
    pref[i] = pref[i - 1] o a[i];
}


then we can find f(i, j) = f(0, j) o' f(0, i - 1) = pref[j] o' pref[i - 1]

q -> O(q)



practice problem :- 
https://practice.geeksforgeeks.org/problems/mean-of-range-in-array2123/1/?category[]=prefix-sum&category[]=prefix-sum&page=1&query=category[]prefix-sumpage1category[]prefix-sum

vector<int> findMean(int arr[],int queries[],int n,int q)
{
    q /= 2;
    vector<int> ans(q);
    
    for(int i = 1; i < n; i++) {
        arr[i] += arr[i - 1];
    }
    
    for(int i = 0; i < q; i++) {
        int l = queries[2 * i];
        int r = queries[2 * i + 1];
        if(l > 0) {
            ans[i] = (arr[r] - arr[l - 1]) / (r - l + 1);
        } else {
            ans[i] = arr[r] / (r + 1);
        }
    }
    
    return ans;
}

so this was prefix function on 1D

can we extend it to 2D?
Yes, we can 

_ _ _ _ _
_ _ _ _ _
_ _ _ _ _
_ _ _ _ _
_ _ _ _ _

here we are given arr matrix of n * n

let's construct a matrix b of n * n, where 
pref[x][y] = f({0, 0}, {x, y}) = Σ(i -> 0 to x) Σ (j -> 0 to y) arr[i][j]


now how can we find f({a, b}, {c, d}), a <= c && b <= d

    0         b        d

0	|------------------|
	|         |        |
	|    I    |   II   | 
	|         |        |	
a	|------------------|
	|         |        |
	|         |        |
	|   III   |   IV   | 
	|         |        |
	|         |        |
c	|------------------|

pref[a, b] = I
pref[a, d] = I + II
pref[c, b] = I + III
pref[c, d] = I + II + III + IV

what is f({a, b}, {c, d}) ?
f({a, b}, {c, d}) is IV
      = (I + II + III + IV) - (I + II) - (I + III) + I
      = pref[c, d]             -  pref[a][d] - pref[c][b]   + pref[a][b]

f({a, b}, {c, d}) = pref[c][d] o' pref[a][d] o' pref[c][b] o pref[a][b]

// calculating pref array
for(int i = 0; i < n; i++) {
    for(int j = 0; j < m; j++) {
        pref[i][j] = arr[i][j];
        if(i - 1 >= 0) {
            pref[i][j] = pref[i][j] + pref[i - 1][j]; 
        }
        if(j - 1 >= 0) {
            pref[i][j] = pref[i][j] + pref[i][j - 1];
        }
        if(i - 1 >= 0 && j - 1 >= 0) {
            pref[i][j] = pref[i][j] - pref[i - 1][j - 1];
        }
    }
}
